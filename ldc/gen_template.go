// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package ldc

// to slice bool
func ToSliceBool(items []interface{}) []bool {
	var result = make([]bool, 0, len(items))
	for _, item := range items {
		result = append(result, item.(bool))
	}
	return result
}

// to slice object by bool
func ToSliceObjByBool(items []bool) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfBool(sta bool, tru bool, fal bool) bool {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice byte
func ToSliceByte(items []interface{}) []byte {
	var result = make([]byte, 0, len(items))
	for _, item := range items {
		result = append(result, item.(byte))
	}
	return result
}

// to slice object by byte
func ToSliceObjByByte(items []byte) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfByte(sta bool, tru byte, fal byte) byte {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice complex128
func ToSliceComplex128(items []interface{}) []complex128 {
	var result = make([]complex128, 0, len(items))
	for _, item := range items {
		result = append(result, item.(complex128))
	}
	return result
}

// to slice object by complex128
func ToSliceObjByComplex128(items []complex128) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfComplex128(sta bool, tru complex128, fal complex128) complex128 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice complex64
func ToSliceComplex64(items []interface{}) []complex64 {
	var result = make([]complex64, 0, len(items))
	for _, item := range items {
		result = append(result, item.(complex64))
	}
	return result
}

// to slice object by complex64
func ToSliceObjByComplex64(items []complex64) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfComplex64(sta bool, tru complex64, fal complex64) complex64 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice error
func ToSliceError(items []interface{}) []error {
	var result = make([]error, 0, len(items))
	for _, item := range items {
		result = append(result, item.(error))
	}
	return result
}

// to slice object by error
func ToSliceObjByError(items []error) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfError(sta bool, tru error, fal error) error {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice float32
func ToSliceFloat32(items []interface{}) []float32 {
	var result = make([]float32, 0, len(items))
	for _, item := range items {
		result = append(result, item.(float32))
	}
	return result
}

// to slice object by float32
func ToSliceObjByFloat32(items []float32) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfFloat32(sta bool, tru float32, fal float32) float32 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice float64
func ToSliceFloat64(items []interface{}) []float64 {
	var result = make([]float64, 0, len(items))
	for _, item := range items {
		result = append(result, item.(float64))
	}
	return result
}

// to slice object by float64
func ToSliceObjByFloat64(items []float64) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfFloat64(sta bool, tru float64, fal float64) float64 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice int
func ToSliceInt(items []interface{}) []int {
	var result = make([]int, 0, len(items))
	for _, item := range items {
		result = append(result, item.(int))
	}
	return result
}

// to slice object by int
func ToSliceObjByInt(items []int) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfInt(sta bool, tru int, fal int) int {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice int16
func ToSliceInt16(items []interface{}) []int16 {
	var result = make([]int16, 0, len(items))
	for _, item := range items {
		result = append(result, item.(int16))
	}
	return result
}

// to slice object by int16
func ToSliceObjByInt16(items []int16) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfInt16(sta bool, tru int16, fal int16) int16 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice int32
func ToSliceInt32(items []interface{}) []int32 {
	var result = make([]int32, 0, len(items))
	for _, item := range items {
		result = append(result, item.(int32))
	}
	return result
}

// to slice object by int32
func ToSliceObjByInt32(items []int32) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfInt32(sta bool, tru int32, fal int32) int32 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice int64
func ToSliceInt64(items []interface{}) []int64 {
	var result = make([]int64, 0, len(items))
	for _, item := range items {
		result = append(result, item.(int64))
	}
	return result
}

// to slice object by int64
func ToSliceObjByInt64(items []int64) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfInt64(sta bool, tru int64, fal int64) int64 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice int8
func ToSliceInt8(items []interface{}) []int8 {
	var result = make([]int8, 0, len(items))
	for _, item := range items {
		result = append(result, item.(int8))
	}
	return result
}

// to slice object by int8
func ToSliceObjByInt8(items []int8) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfInt8(sta bool, tru int8, fal int8) int8 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice rune
func ToSliceRune(items []interface{}) []rune {
	var result = make([]rune, 0, len(items))
	for _, item := range items {
		result = append(result, item.(rune))
	}
	return result
}

// to slice object by rune
func ToSliceObjByRune(items []rune) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfRune(sta bool, tru rune, fal rune) rune {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice string
func ToSliceString(items []interface{}) []string {
	var result = make([]string, 0, len(items))
	for _, item := range items {
		result = append(result, item.(string))
	}
	return result
}

// to slice object by string
func ToSliceObjByString(items []string) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfString(sta bool, tru string, fal string) string {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uint
func ToSliceUint(items []interface{}) []uint {
	var result = make([]uint, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uint))
	}
	return result
}

// to slice object by uint
func ToSliceObjByUint(items []uint) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUint(sta bool, tru uint, fal uint) uint {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uint16
func ToSliceUint16(items []interface{}) []uint16 {
	var result = make([]uint16, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uint16))
	}
	return result
}

// to slice object by uint16
func ToSliceObjByUint16(items []uint16) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUint16(sta bool, tru uint16, fal uint16) uint16 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uint32
func ToSliceUint32(items []interface{}) []uint32 {
	var result = make([]uint32, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uint32))
	}
	return result
}

// to slice object by uint32
func ToSliceObjByUint32(items []uint32) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUint32(sta bool, tru uint32, fal uint32) uint32 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uint64
func ToSliceUint64(items []interface{}) []uint64 {
	var result = make([]uint64, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uint64))
	}
	return result
}

// to slice object by uint64
func ToSliceObjByUint64(items []uint64) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUint64(sta bool, tru uint64, fal uint64) uint64 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uint8
func ToSliceUint8(items []interface{}) []uint8 {
	var result = make([]uint8, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uint8))
	}
	return result
}

// to slice object by uint8
func ToSliceObjByUint8(items []uint8) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUint8(sta bool, tru uint8, fal uint8) uint8 {
	if sta {
		return tru
	} else {
		return fal
	}
}

// to slice uintptr
func ToSliceUintptr(items []interface{}) []uintptr {
	var result = make([]uintptr, 0, len(items))
	for _, item := range items {
		result = append(result, item.(uintptr))
	}
	return result
}

// to slice object by uintptr
func ToSliceObjByUintptr(items []uintptr) []interface{} {
	var result = make([]interface{}, 0, len(items))
	for _, item := range items {
		result = append(result, item)
	}
	return result
}

// if sta return tru else return fal
func IfUintptr(sta bool, tru uintptr, fal uintptr) uintptr {
	if sta {
		return tru
	} else {
		return fal
	}
}
